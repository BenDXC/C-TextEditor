name: Label PRs Based on Title

on:
  pull_request:
    types:
      - opened
      - edited
      - synchronize

jobs:
  label-pr:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Label PR based on title and description (case-insensitive, multi-keyword)
        run: |
          # Retrieve PR title and body
          pr_title=$(jq --raw-output .pull_request.title "$GITHUB_EVENT_PATH")
          pr_body=$(jq --raw-output .pull_request.body "$GITHUB_EVENT_PATH")
          pr_number=$(jq --raw-output .pull_request.number "$GITHUB_EVENT_PATH")
          
          # Enable case-insensitive matching
          shopt -s nocasematch

          # Function to add label if it doesn't already exist
            add_label_if_missing() {
              # Get the current labels applied to the PR
              current_labels=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                "https://api.github.com/repos/${{ github.repository }}/issues/$pr_number/labels" | jq -r '.[].name')
            
              # Check if the label already exists in the list of current labels
              if echo "$current_labels" | grep -q -i "$1"; then
                echo "Label '$1' already exists, skipping."
              else
                echo "Labeling PR as '$1'"
                # Add the label to the PR
                curl -X POST -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  -H "Accept: application/vnd.github.v3+json" \
                  -d "{\"labels\":[\"$1\"]}" \
                  "https://api.github.com/repos/${{ github.repository }}/issues/$pr_number/labels"
              fi
            }


          # Label as feature if PR title/description contains any of 'feat', 'feature', 'enhance'
          if [[ "$pr_title" =~ \b(feat|feature|enhance)\b || "$pr_body" =~ \b(feat|feature|enhance)\b ]]; then
            add_label_if_missing "feature"

          # Label as bugfix if PR title/description contains any of 'fix', 'bug', 'issue'
          elif [[ "$pr_title" =~ \b(fix|bug|issue)\b || "$pr_body" =~ \b(fix|bug|issue)\b ]]; then
            add_label_if_missing "bugfix"

          # Label as breaking-change if PR title/description contains 'BREAKING CHANGE'
          elif [[ "$pr_title" =~ \bBREAKING CHANGE\b || "$pr_body" =~ \bBREAKING CHANGE\b ]]; then
            add_label_if_missing "breaking-change"

          # Label as documentation if PR title/description contains 'docs', 'documentation'
          elif [[ "$pr_title" =~ \b(docs|documentation)\b || "$pr_body" =~ \b(docs|documentation)\b ]]; then
            add_label_if_missing "documentation"

          # Label as enhancement if PR title/description contains any of 'enhance', 'improvement'
          elif [[ "$pr_title" =~ \b(enhance|improvement)\b || "$pr_body" =~ \b(enhance|improvement)\b ]]; then
            add_label_if_missing "enhancement"

          # Label as performance if PR title/description contains 'perf', 'performance'
          elif [[ "$pr_title" =~ \b(perf|performance)\b || "$pr_body" =~ \b(perf|performance)\b ]]; then
            add_label_if_missing "performance"

          # Label as refactor if PR title/description contains 'refactor'
          elif [[ "$pr_title" =~ \brefactor\b || "$pr_body" =~ \brefactor\b ]]; then
            add_label_if_missing "refactor"

          # Label as ci/cd if PR title/description contains 'ci', 'cd'
          elif [[ "$pr_title" =~ \b(ci|cd)\b || "$pr_body" =~ \b(ci|cd)\b ]]; then
            add_label_if_missing "ci/cd"

          # Label as security if PR title/description contains 'security'
          elif [[ "$pr_title" =~ \bsecurity\b || "$pr_body" =~ \bsecurity\b ]]; then
            add_label_if_missing "security"

          # Label as test if PR title/description contains 'test', 'tests'
          elif [[ "$pr_title" =~ \b(test|tests)\b || "$pr_body" =~ \b(test|tests)\b ]]; then
            add_label_if_missing "test"

          # Default label (if no match)
          else
            add_label_if_missing "misc"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
